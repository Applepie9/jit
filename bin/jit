#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"
require "pathname"

require_relative "../lib/repository"

command = ARGV.shift

case command
when "init"
  path = ARGV.fetch(0, Dir.getwd)

  root_path = Pathname.new(File.expand_path(path))
  git_path = root_path.join(".git")

  %w[objects refs].each do |dir|
    FileUtils.mkdir_p(git_path.join(dir))
  rescue Errno::EACCES => e
    warn "fatal: #{e.message}"
    exit 1
  end

  puts "Initialized empty Jit repository in #{git_path}"
  exit 0

when "add"
  root_path = Pathname.new(Dir.getwd)
  repo = Repository.new(root_path)

  begin
    repo.index.load_for_update
  rescue Lockfile::LockDenied => e
    warn <<~ERROR
      fatal: #{e.message}

      Another jit process seems to be running in this repository.
      Please make sure all processes are terminated then try again.
      If it still fails, a jit process may have crashed in this
      repository earlier: remove the file manually to continue.
    ERROR
    exit 128
  end

  begin
    paths = ARGV.flat_map do |file_path|
      path = Pathname.new(File.expand_path(file_path))
      repo.workspace.list_files(path)
    end
  rescue Workspace::MissingFile => e
    warn "fatal: #{e.message}"
    repo.index.release_lock
    exit 128
  end

  begin
    paths.each do |file_path|
      data = repo.workspace.read_file(file_path)
      stat = repo.workspace.stat_file(file_path)

      blob = Database::Blob.new(data)
      repo.database.store(blob)
      repo.index.add(file_path, blob.oid, stat)
    end
  rescue Workspace::NoPermission => e
    warn "error: #{e.message}"
    warn "fatal: adding files failed"
    repo.index.release_lock
    exit 128
  end

  repo.index.write_updates
  exit 0

when "commit"
  root_path = Pathname.new(Dir.getwd)
  repo = Repository.new(root_path)

  repo.index.load

  root = Database::Tree.build(repo.index.each_entry)
  root.traverse { |tree| repo.database.store(tree) }

  parent  = repo.refs.read_head
  name    = ENV.fetch("GIT_AUTHOR_NAME")
  email   = ENV.fetch("GIT_AUTHOR_EMAIL")
  author  = Database::Author.new(name, email, Time.now)
  message = $stdin.read

  commit = Database::Commit.new(parent, root.oid, author, message)
  repo.database.store(commit)
  repo.refs.update_head(commit.oid)

  is_root = parent.nil? ? "(root-commit) " : ""
  puts "[#{is_root}#{commit.oid}] #{message.lines.first}"
  exit 0

else
  warn "jit: '#{command}' is not a jit command."
  exit 1
end
